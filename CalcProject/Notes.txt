Git
Commit - фіксація, "знімок" стану у якому зберігаються зміни по
відношенню до попереднього стану:
 - додано
 - змінено
 - видалено
Що НЕ має передаватись на Git
 - тичасові файли (як компілятору, так і оточення - студії)
 - виконавчі файли та інші результати зборки
 - завантажені пакети та залежності (те, що завжди можна
    дозавантажити)
== У репозиторії має бути код і тільки код

Обмеження на передачу файлів задаються файлом .gitignore

Є дві ситуації 
 1. проєкт існує локально і його треба відправити на Git
 2. проєкт існує на Git і його треба скопіювати локально

1. Проєкт треба ініціювати (git init), це створить папку .git
у проєкті, до якої будуть включені необхідні речі
 !! там є персанальні дані, не слід цю папку передавати 
    третім особам
2. Додаємо .gitignore - файл з виключеннями, які НЕ повинні
передаватись у репозиторій. Цей файл створюється з урахуванням
оточення - мови програмування, "студії", тощо. Універсального
не існує.
Але можна створювати .gitignore у кожній папці окремо
3. Робимо commit:
  > git add ./      додати файли до коміту
  > git commit -m "Commit message"      фіксація змін (коміт - архів змін)
  > git push --all       надіслати коміт до віддаленного репозиторію  

Д.З. Створити конфлікт злиття через внесення змін з різних
терміналів (Студія / Веб-Гітхаб)
Створити скриншот графу мережної активності
* створити граф (фрагмент), що є логотипом Гіт 

2. проєкт існує на Git і його треба скопіювати локально
  (для колективної роботи)
 - створюється команда проєкту: власник проєкту надсилає
    запрошення для інших учасників
 - інші учасники приймають (або не приймають) ці запрошення
 - клонуємо проєкт (створюємо власну копію на локальному ПК)
 - вносимо зміни у один файл, зберігаємо, запускаємо (це 
    створить службові файли) - переконуємось, що у Гіт-змінах
    лише один файл. Якщо спостерігаємо додаткові зміни, 
    доповнюємо .gitignore
 - зміни, що внесені різними учасниками в один файл, викликають
    конфлікти, що потребують злиття.
 - зміни у різних файлах призводять до конфліктів, але їх
    "студія" вирішує автоматично

----------------------------------------------------------------
Тестування (Модульне тестування)
 - Є різні системи (засоби) тестування. У нас - MSTest
    Різні системи можуть як по-різному оформлювати тести, 
    так і по-різному їх створювати
 - Тести складаються з тверджень (Asserts)
    твердження перевіряються і можуть бути підтверджені або спростовані
    якщо всі твердження підтверджені, то тест вважається пройденим
    якщо хоча б одне твердження спростоване, то весь тест вважається
     проваленим (Fail)
 - Прийнято групувати тести з невеликою або тематичною підбіркою
    тверджень для того щоб провал одного з тестів інформував нас
    про походження помилки
     Не рекомендується: скласти всі твердження в один тест
     Рекомендується: розподілити твердження по різним тестам
 - Різні системи по-різному групують, у MSTest мінімальною
    одиницею звітності є тестовий метод

-----------------------------------------------------------------------
Рефакторинг
Ідея ХР полягає у циклічності процесу
   Тести - Код - Рефракторинг. 
Періодично цей цикл додається ТЗ (завдання). Але і без нього
 цей цикл має перебігати постійно.
У ХР рефакторинг - неодмінна частина процесу створення ПЗ.

Рефакторинг - прийом у програмуванні, призначений для покращення коду.
!! Рефакторинг не змінює функціональність !!
Не плутати з оптимізацією, за якої вона змінюється.
Рефакторинг не зачіпає алгоритми, а лише їх реалізацю

Рефакторинг можна порівняти з патернами проєктування - це набір
 правил, прийомів, заходів, критеріїв, що впроваджуються у код.
 Можна казати про автоматизований рефакторинг - формальне застосування
 до коду зазначених правил.

Технічний борг (Technical Debt) - накопичення невиконаних завдань з 
 покращення коду, частіше за все - з рефакторингу.
 Код з накопиченим боргом називають "смердячим", наявні недоліки
 називають "запахами"

Наявність боргів дуже ускладнює розвинення проєкту, внесення до нього 
 змін та нових функцій.

Критерії якісного (чистого) коду:
 - Зрозумілий для інших програмістів
 - Проходить усі тести
 = Не містить повторів (зв'язного дублювання) :
    зміни в одному місці неодмінно мають дублюватись в іншому
 = Використовує мінімальну кількість структурних елементів
    (абстракцій)
 = Логічно згрупований 
    кожен елемент (клас, метод, функція) цілісна і може бути названа
    (назва свідчить про функціональність)
    - і з точки зору мінімальності (немає зайвого - занадто розділений)
    - і з точки зору максимальності (немає об'єднань - занадто з'єднаний)

Методи (прийоми) рефакторингу
= Перегрупування об'єктів : прийом призначений для змін у способі (схемі)
   групування об'єктів, ієрархії їх класів та інтерфейсів
 - Розділення
    * Виділення підкласів
    * Виділення суперкласів
    * Створення інтерфейсів
 - З'єднання (Collapses)
    * З'єднання класів
    * З'єднання інтерфейсів
 - Реогранізація
    * Перенесення вгору
    * Перенесення вниз
    * Зміна зв'язків (наслідування на агрегацію на навпаки)

 = Зміна викликів методів (сигнатур функцій) : перетворення декларацій
    функцій, процедур, методів задля рефакторингу
  - Зміна у параметрах
     * Додавання параметрів
     * Вилучення параметрів
     * Групування параметрів (об'єкти як параметри)
  - Зміни у назвах та видності (private/public)
     * Приховування методів
     * Перейменування методів (та параметрів)
  - Зміни у поверненні
     * Перетворення на фабрику (повернення об'єктів)
     * Виключення (Exception) або повернення помилки

 = Зміна інструкцій керування (виконанням коду) : реорганізація
    операторів умов та циклів
  - Конструкції розгалуження (if/switch)
     * Композиція (з'єднання) умов (умовних виразів / case) 
     * Декомпозиція
     * Інверсія умов (if)
     * Заміна поліморфізмом
     * Заміна if/switch
  - Циклові конструкції
     * Лінеаризація / зациклювання
     * Заміна умовних циклів та лічильників

 = Реогранізація даних : прийоми, що змінюють структури даних, їх
    інкапсуляцію та зв'язність (асоциативність)
  - Зміни типу
     * Reference/Value - type
     * Прімитивні типи / об'єкти
     * Масиви / об'єкти
  - Зміни групування
     * Інкапсуляція даних (перенесення до об'єкту)
     * Вилучення даних з об'єктів (розділення) 
  - Зміни зв'язності
     * Введення констант замість "магічних чисел", 
        методів замість констант
     * Вилучення зв'язків "один-до-одного"

 = Реорганізація коду (методів/функцій) : зміна розподілу коду за 
    частинами, перенесення частин між об'єктами
  - Зміни групування
     * Інкапсуляція методів (перенесення до об'єкту)
     * Вилучення методів з об'єктів (розділення) 
     * Відмова від метода (Inline-метод)
  - Реорганізація
     * Розділення методів (декілька замість одного)
     * Об'єднання методів
     * Переміщення за ієрархією об'єктів (класів)
     * Перетворення на static Extension (Prototype)

Закінчити роботу з кодом та тестами динамічних та статичних методів Add

---------------------------------------------------------------------
Рефакторинг. Практика.
1. Найбільшу проблему створюють методи з дублюванням коду.
  Під дублюванням розуміємо необхідність вносити зміни у декілька місць
  одночасно.
  Методи Add - проблема дублювання. Кожен з методів реалізовує алгоритм
  додавання всередині себе (оператор +). Якщо треба змінити алгоритм, то
  у всіх методах одночасно.
  Рішення: реалізувати алгоритм в одному з методів, а з ішних методів
  викликати його
  Add(x,y){x+y}  Add(A,B){A+B}  ---> Add(x,y){x+y}  Add(A,B){Add(A.x,B.y)}

  Який метод слід вибрати за опорний?
  Роздуми: цілісною сутністю є об'єкт. Алгоритм додавання стосується
   об'єктів. Тому за опорний краще взяти алгоритм, що оперує об'єктами
------------------------------------------------------------------------
Рефакторинг. Практика.
"Магічні" значення -> константи -> методи -> ресурси
"Магічні" значення (Hardcoded) - значення, що є даними, але розміщені у коді.
 Головна концепція - розділяти дані та код. Розміщення даних у коді
 значно погіршує їх розділеність та показники безпеки, що з цього слідують.

1. Проводимо аналіз коду, знаходимо рядки (рядкові вирази), числа (можливо,
 окрім нуля), створюємо з них константи.
 Якщо рядки передабачають плейсхолдери (підстановку даних), то створюємо
 рядкові шаблони, у яких місце для даних замінюється на правило підстановки.
   const String EMPTY_STRING_MESSAGE  = "Empty string not allowed";
   const String INVALID_DIGIT_MESSAGE = "Invalid digit '%c'";
   ....
   throw new ArgumentException(
        INVALID_DIGIT_MESSAGE.Replace("%c", str[pos].ToString())
    );
 2. Відокремлюємо ресурси - окремий об'єкт, метою якого є надання ресурсів,
  у тому числі підстановка плейсхолдерів, у тому числі локалізація - 
  створення різних варіантів для різних культур.
  Культурою (у програмуванні) називають комбінацію мови і країни для
  якої будуються ресурси. Загальноприйнятим стандартом є вживання
  культури у вигляді "хх-ХХ"
  хх - мова за ISO 639-1
  XX - країна за ISO 3166-1
  наприклад, "uk-UA", "ru-UA", "en-US"

------------------------------------------------------------------------
Рефакторинг. Інверсія управління.
Загальна ідея - відмовляємось від "глобальних" (статичних) об'єктів
1. Простий варіант: знаходиться точка старту програми,
 в ній створюються необхідні об'єкти, вони передаються далі
 усім іншим об'єктам, які від них залежать
2. Встановити контейнер керування залежностями (наприклад, Unity.NetCore).
 
деякі схеми:
клас -> об'єкт -> впровадження у інші об'єкти (реєстрація екземплярів)
клас -> впроваджується (реєстрація типів). Об'єкт створюється при першому зверненні
клас <- інтерфейс -> впроваджується (реєстрація імплементацій типів)
Сінглтон (сумнівний, інколи вважається антипатерном)
